## 책임연쇄 (Chain of Responsibility)

### 목적
메시지를 보내는 객체와 처리하는 객체들간의 결합도를 없앤다.
하나의 요청에 대한 처리가 반드시 한 객체에서만 되지 안혹 여러 객체에게 그 처리 기회를 줌.

### 활용
- 하나 이사의 객체가 요청을 처리해야하고 어떤게 선행되어야하는지 모를때. 처리하는 애가 자동으로 확정되어야함
- 메시지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶을때.
- 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할때.

### 활용예제
- 위젯의 도움말 제공: 다이얼로그에서 확인 버튼 -> 감싸고있는애가 도움말을 갖고있나? 있으면 그거 리턴 없으면 또 그걸 감싸고 있는 애가 도움말을 갖고있나? -> ...
  

### 구조
- handler(예제의 dealer)를 구현한 concreateHandler
- client는 처리를 요청하고 resolve할수있는 ConcreteHandler를 만날때까지 연결고리를 따라서 계속 전달

### 구현
- 연결고리를 구현하는방법
  
  * 새로운 연결을 만듬(일반적으로 handler클래스에 정의. concreteHandler클래스에 정의하기도함)
  * 이미 있는 연결을 사용
    *  Composite패턴이 적용되어있으면 위의 활용예제와 같이 기존에 존재하는 체인 구조 그대로 사용.
    *  Composite패턴이 있더라도 구성하려는 체인의 구조와 Composite체인의 구조가 다르다면 걍 새로만들어야함
- 요청하는 매개변수를 별도의 객체로 만든다(예제의 Notice). 새로운 요청이 나오면 Notice를 상속받아서 구현한다.


### 장점
- 객체 간의 행동적 결합도가 적어진다. (처리하는애는 자신과 연결된(next) 단 하나의 후보객체만 알면 된다)
- 객체에게 책임을 할당하는데 유연성을 높일수 있다(객체의 책임을 여러 객체에게 분산시킬 수 있으므로 런타임에 연결고리를 변경하너가 추가가능)

### 단점
- 메시지 수신이 보장되지 않음: 객체들간의 연결 고리가 잘 정의됮 않으면 요청은 처리되지 못한 채로 버려질 수 있다.
- 요청을 처리할수있는 책임자를 찾느라 if-statement등을 사용해야하므로 직접 할당하는것보다 속도가 느리다(예측하기 힘들다)
- 책임자의 순서를 결정할때도 신중해야해


### 참고
- 열혈강의 자바 디자인패턴