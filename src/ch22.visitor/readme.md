## 방문자 (Visitor)

### 동기
작업 대상과 작업 항목을 분리시킨다. (= 데이터와 알고리즘을 분리시켜준다)
같은 자료형의 여러 객체에 대해 다양한 작업을 수행하고싶다!
(= 새로운 **작업** 추가가 많은 경우 Visitor패턴을 활요하면 유용하다)

### 구조
![visitor](visitor.png)

### 활용
- 다양한 인터페이스를 가진 객체 여러 개에 대해 그들의 자료형에 따라 각각의 작업을 수행하고 싶을때
- 객체 여러개에 대해 다양한 작업을 수행하고 싶은데, 각각의 작업들 간에는 연관성이 적고 개별객체마다 원하는 작업을 멤버함수로 추가 정의하는것은 지저분해서 피하고싶을때
- 작업 대상이 되는 클래스 구조는 확장될 가능성이 없는 대신 수행할 작업 항목은 계속해서 추가, 확장될 소지가 많을때
  

### 단점
- 작업 대상의 추가, 확장이 어렵다. 새로운 작업대상(Element)이 추가되면 Visitor 및 하위 클래스 모두에 새로운 멤버함수를 추가해야한다.
  -> 알고리즘이 주로 변경되는지 데이터가 주로 변경되는지 검토후 도입해야함.

### 장점
- 객체들의 특정 상태 값을 누적, 관리하게 만들 수 있다(history): 이때 누적된 상태 값은 전역 변수에 저장되거나 다음 객체를 방문할 때 인자로 전달되어 수행할 작업이나 알고리즘을 변경하게 만들 수도 있다.
- 작업 항목 객체가 작업 수행 시 작업 대상 객체의 데이터를 참조하는 구조다: visitor패턴이 제대로 동작하려면 Visitor가 참조하는 데이터에 대해서는 Element가 충분한 인터페이스를 제공해야함. (Visitor - Element 결합도 증가)

### 관련패턴
- 객체 여러개에 대한 동일한 작업을 수행하는걸 `Iterator`패턴으로 사용할 수 있다
    - Iterator는 작업 대상객체가 모두 동일한 자료형이어야 하는데 Visitor는 아니어도된다.
- `Composite` 객체를 구성하는 개별 객체들에 대해 특정 작업을 수행하게 해준다.
- `interpreter`패턴에서 다룬 문제를 해결하는데도 유용하다. 객체 여러개에 대해 다양한 작업을 수행하는게 가능.